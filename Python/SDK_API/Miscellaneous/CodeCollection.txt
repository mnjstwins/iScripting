Message Box
	print win32gui.MessageBox(None, 'Delete?', 'Confirm', win32con.MB_YESNO)

Swap the variables' value
	a=3
	b=4
	(a,b) = (b,a)

GUI与多线程
	GUI似乎是不断地得到消息并处理消息而工作的，因此为了保持它的连贯性，常用多线程来处理一些耗时较长，甚至可能出现假死的过程。
	而在线程中常需要不断地反馈信息到GUI中，让用户了解目前的工作进度和具体情况，这就牵涉到在线程中操作GUI。
实践证明，直接在线程中操作GUI有可能成功，但即使这一次成功了，也不能保证下一次程序仍不会崩溃，因此，寻求一个更安全可靠的方法是必要的。
VB中，线程的概念似乎不那么重要，而且在VB中对GUI的操作也相对简单，直接赋值就可以了，因此一般不会出现因为操作GUI而崩溃的现象。似乎VB已经充分考虑过了这些问题，而且已经通过内在的机制确保了在各种情况下控制GUI的安全。印象中VB的崩溃常出现在强行修改VB的窗口主循环然后出错时……
	C语言中直接在线程中调用绘制的函数好像也没有出现崩溃的现象，可能是因为我的程序比较简单，尽管这样，还是由于同时调用绘制函数出现了一些意想不到的现象，比如线程中绘制的东西与REPAINT的东西相冲突出现紊乱。我觉得一个比较靠得住的方法是PostMessage一个WM_PAINT消息，可以先将要绘制的东西通过其它方式存储到公共的空间里，然后PostMessage，还可以通过修改PostMessage的参数（wParam和lParam）来识别当前获取的WM_PAINT消息是系统要求的REPAINT还是线程要求的绘制。
	Python跟C有点像，而且Python线程中操控GUI尤其容易崩溃，我通过Tkinter（Tk/Tcl）绘制的GUI，在线程中直接操作就会崩溃，而Python中我没有找到类似PostMessage的命令，至少Tkinter中没找到（似乎wxPython中有，但哥就是喜欢用标准库……），也就是说，Tkinter中的mainloop是固定的无法修改也无法增加新的消息进去。
不过，好在Tkinter中还有一个after命令，可以设置一定时间后在主线程中运行某个函数，于是我建立了一个Events数组（类似于一个Queue）用来保存消息，然后每隔一定时间（如20ms）就调用一个自己建立的用来处理消息的EventHandler函数，检测这个数组中是否有新的消息，有消息就处理掉，这样就只需要在线程中向这个Events数组中添加消息，于是达到了PostMessage的效果。当然，在每次EventHandler函数的最后，都要设置隔一定时间（如20ms）后再次（通过Tk.after）调用这个函数。
	总的来说，GUI在线程中最好不要直接操作，一般思路还是应该通过发送消息然后在主线程中回调来实现GUI的操作。
